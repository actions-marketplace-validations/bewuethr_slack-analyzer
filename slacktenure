#!/usr/bin/env bash

# Fetch complete users list from Slack API
getusers() {
	curl https://slack.com/api/users.list \
		--silent \
		--get \
		--data 'pretty=1' \
		--header "Authorization: Bearer $BOT_TOKEN"
}

# Remove bot and guest users
extractfullusers() {
	jq '
		.members |
		map(select(
			(
				.is_bot or .is_restricted |
				not
			)
			and .name != "slackbot"
		))
	'
}

# Fetch all users and extract full users
getfullusers() {
	getusers | extractfullusers
}

# Retrieve first or last message for user from Slack API; sleep to avoid
# hitting rate limit
findmsg() {
	local userid=$1
	local dir=$2
	curl https://slack.com/api/search.messages \
		--silent \
		--get \
		--data 'pretty=1' \
		--data-urlencode "query=from:<@$userid>" \
		--data 'count=1' \
		--data 'sort=timestamp' \
		--data "sort_dir=$dir" \
		--header "Authorization: Bearer $USER_TOKEN"

	sleep 3
}

# Find first message from user
findfirst() {
	local userid=$1
	findmsg "$userid" 'asc'
}

# Find last message from user
findlast() {
	local userid=$1
	findmsg "$userid" 'desc'
}

# Extract timestamp from message search result; return non-zero exit status if
# user has no messages at all
msg2timestamp() {
	jq --raw-output '
		if .messages.total == 0 then
			"" | halt_error(1)
		else
			.messages.matches[0].ts |
			if test("[.]") then
				split(".")[0]
			else
				.
			end
		end
	'
}

# Convert user JSON to TSV input required for first/last lookup
extractids() {
	jq --raw-output '
		map([.id, .profile.real_name, .deleted, .profile.title]) |
		.[] |
		@tsv
	'
}

# Print user status and timestamps of the first and last ever message of the
# provided user; a user can have a status and zero, one, or two timestamps; if
# the user does not exist in infile (usually tenures.tsv), nothing is printed
gettenure() {
	local id=$1
	local infile=$2
	awk --field-separator '\t' --assign id="$id" '
		$1 == id {
			printf $4
			if ($5) {
				printf " " $5
				if ($6) {
					printf " " $6
				}
				print ""
			}
	}' "$infile"
}

# For each user, determine if new information might be available and fetch it
# to update the record.
tenureupdate() {
	local infile=$1

	printf '%s\t%s\t%s\t%s\t%s\t%s\n' 'id' 'name' 'title' 'status' 'first' 'last'

	local id name deleted title
	while IFS=$'\t' read -r id name deleted title; do
		local oldstatus first last
		read -r oldstatus first last <<< "$(gettenure "$id" tenures.tsv)"
		local status=${oldstatus:=fresh}

		case $oldstatus in
			'active')
				if [[ $deleted == 'true' ]]; then
					# Newly alum, get last
					status='alum'
					last=$(findlast "$id" | msg2timestamp)
				fi
				;;

			'fresh')
				if first=$(findfirst "$id" | msg2timestamp); then
					status='active'
				fi

				if [[ $deleted == 'true' ]]; then
					if [[ $status == 'active' ]]; then
						status='alum'
						last=$(findlast "$id" | msg2timestamp)
					else
						status='noshow'
					fi
				fi
				;;
		esac

		printf '%s\t%s\t%s\t%s\t%s\t%s\n' "$id" "$name" "$title" "$status" "$first" "$last"
		unset id name deleted title first last status
	done < <(extractids < "$infile")
}

# Filter for tenures.tsv to remove headers, drop status field, sort by join
# date, convert Unix timestamp to YYYY-MM-DD, and add employee number
prettyprint() {
	sed '1d' \
		| cut --fields=4 --complement \
		| sort --numeric-sort --key=4,4 --field-separator=$'\t' \
		| awk --field-separator='\t' --assign OFS='\t' '
			$4 {
				$4 = strftime("%F", $4)
				if ($5)
					$5 = strftime("%F", $5)
				print
			}
		' \
		| nl
}

# Filter for tenures.tsv to remove headers, sort by join date, filter for
# active users, convert Unix timestamp to YYYY-MM-DD, and add current employee
# number
prettyprintcurrent() {
	sed '1d' \
		| sort --numeric-sort --key=5,5 --field-separator=$'\t' \
		| awk --field-separator='\t' --assign OFS='\t' '
			$4 == "active" {
				print $1, $2, $3, strftime("%F", $5)
			}
		' \
		| nl
}

# Filter for prettyprint output to terminal
tocolumn() {
	column --table --separator=$'\t' --table-truncate=4
}

# Filter to convert tab separated input to body of Markdown table
mdtablebody() {
	sed -E '
		s/^ +//     # Remove leading blanks
		s/\|/\\|/g  # Escape existing pipes
		s/\t/ | /g  # Replace tabs with pipes
		s/ +$//     # Remove trailing blanks
	'
}

# Filter for prettyprint output to Markdown
tomarkdown() {
	local title=$1
	printf '%s\n\n' "# $title"
	printf '%s | %s | %s | %s | %s | %s\n' '\#' "User ID" "Name" "Title" "Joined" "Left" \
		'-:' '-' '-' '-' '-' '-'

	mdtablebody

}

# Filter for prettyprintcurrent output to Markdown
tomarkdowncurrent() {
	local title=$1
	printf '%s\n\n' "# $title"
	printf '%s | %s | %s | %s | %s\n' '\#' "User ID" "Name" "Title" "Joined" \
		'-:' '-' '-' '-' '-'

	mdtablebody
}

# Make sure required environment variables are defined
checkenvvars() {
	local envvar
	for envvar in BOT_TOKEN USER_TOKEN; do
		if [[ -z ${!envvar} ]]; then
			echo "$envvar must be set" >&2
			return 1
		fi
	done

	return 0
}

main() {
	checkenvvars || exit 1

	local title=${1:-Tenures}

	getfullusers > users.json
	tenureupdate users.json > tenures_new.tsv
	rm users.json

	local difffile
	difffile="diffs/update-$(date '+%F-%H').diff"
	diff --unified tenures.tsv tenures_new.tsv | tee "$difffile"
	mv tenures_new.tsv tenures.tsv

	if ! [[ -s $difffile ]]; then
		echo "Nothing changed!" >&2
		rm "$difffile"
		exit
	fi

	prettyprint < tenures.tsv | tomarkdown "$title" > tenures.md
}

[[ ${BASH_SOURCE[0]} == "$0" ]] && main "$@"
